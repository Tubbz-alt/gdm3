Original patch: b21df58001691866b54ed4e0bf6d3d12ca6b4fa9
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 18 May 2011 01:49:22 -0400
Subject: [PATCH] daemon: parameterize create_display

There's some logic in create_display and friends,
that would be good to reuse for transient displays.

This commit adds a type argument to create_display
to say what kind of display to create.

Right now it only supports the one type it's always
supported, but that will change in a follow up commit.

https://bugzilla.gnome.org/show_bug.cgi?id=618047

Updated for changes in gdm 3.2.

Index: gdm-3.2.1.1/daemon/gdm-local-display-factory.c
===================================================================
--- gdm-3.2.1.1.orig/daemon/gdm-local-display-factory.c	2011-10-19 17:41:52.000000000 +0200
+++ gdm-3.2.1.1/daemon/gdm-local-display-factory.c	2011-12-17 15:07:18.170152831 +0100
@@ -64,7 +64,8 @@ static void     gdm_local_display_factor
 static void     gdm_local_display_factory_init          (GdmLocalDisplayFactory      *factory);
 static void     gdm_local_display_factory_finalize      (GObject                     *object);
 
-static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory);
+static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory,
+                                                         GType                        type);
 
 static gpointer local_display_factory_object = NULL;
 
@@ -275,9 +276,9 @@ gdm_local_display_factory_create_product
 }
 
 static void
-on_static_display_status_changed (GdmDisplay             *display,
-                                  GParamSpec             *arg1,
-                                  GdmLocalDisplayFactory *factory)
+on_display_status_changed (GdmDisplay             *display,
+                           GParamSpec             *arg1,
+                           GdmLocalDisplayFactory *factory)
 {
         int              status;
         GdmDisplayStore *store;
@@ -300,7 +301,7 @@ on_static_display_status_changed (GdmDis
                 gdm_display_store_remove (store, display);
                 /* reset num failures */
                 factory->priv->num_failures = 0;
-                create_display (factory);
+                create_display (factory, GDM_TYPE_STATIC_DISPLAY);
                 break;
         case GDM_DISPLAY_FAILED:
                 /* leave the display number in factory->priv->displays
@@ -313,7 +314,7 @@ on_static_display_status_changed (GdmDis
                         /* FIXME: should monitor hardware changes to
                            try again when seats change */
                 } else {
-                        create_display (factory);
+                        create_display (factory, GDM_TYPE_STATIC_DISPLAY);
                 }
                 break;
         case GDM_DISPLAY_UNMANAGED:
@@ -329,25 +330,26 @@ on_static_display_status_changed (GdmDis
 }
 
 static GdmDisplay *
-create_display (GdmLocalDisplayFactory *factory)
+create_display (GdmLocalDisplayFactory *factory,
+                GType                   type)
 {
         GdmDisplay *display;
         guint32     num;
 
         num = take_next_display_number (factory);
 
-#if 0
-        display = gdm_static_factory_display_new (num);
-#else
-        display = gdm_static_display_new (num);
-#endif
+        if (type == GDM_TYPE_STATIC_DISPLAY) {
+                display = gdm_static_display_new (num);
+        } else {
+                g_assert_not_reached ();
+        }
 
         /* FIXME: don't hardcode seat1? */
         g_object_set (display, "seat-id", CK_SEAT1_PATH, NULL);
 
         g_signal_connect (display,
                           "notify::status",
-                          G_CALLBACK (on_static_display_status_changed),
+                          G_CALLBACK (on_display_status_changed),
                           factory);
 
         store_display (factory, num, display);
@@ -374,7 +376,7 @@ gdm_local_display_factory_start (GdmDisp
         ret = TRUE;
 
         /* FIXME: use seat configuration */
-        display = create_display (factory);
+        display = create_display (factory, GDM_TYPE_STATIC_DISPLAY);
         if (display == NULL) {
                 ret = FALSE;
         }
