From ccc006a869f0e24835da68402ceb5a4323b7ceb9 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 18 May 2011 02:03:42 -0400
Subject: [PATCH] daemon: share display respawn logic betewen static and
 transient displays

Right now we ignore transient displays after they're created.  We make
no attempt to clean them up from the display store or put the user on
a login screen when their display ends or anything like that.

This commit changes the display factory to monitor transient display
status in much the same way it monitors static display status.

Note for static displays we always respawn when finishing, where
as with transient displays either die quietly, jump to an existing
login display, or respawn.

https://bugzilla.gnome.org/show_bug.cgi?id=618047
---
 daemon/gdm-local-display-factory.c |   43 +++++++++++++++++------------------
 1 files changed, 21 insertions(+), 22 deletions(-)

Index: gdm-3.4.1/daemon/gdm-local-display-factory.c
===================================================================
--- gdm-3.4.1.orig/daemon/gdm-local-display-factory.c	2012-06-09 17:17:04.007788210 +0200
+++ gdm-3.4.1/daemon/gdm-local-display-factory.c	2012-06-09 17:20:47.564881097 +0200
@@ -224,21 +224,8 @@ gdm_local_display_factory_create_transie
 
         ret = FALSE;
 
-        num = take_next_display_number (factory);
-
-        g_debug ("GdmLocalDisplayFactory: Creating transient display %d", num);
-
-        display = gdm_transient_display_new (num);
-
         seat_id = get_seat_of_transient_display (factory);
-        g_object_set (display, "seat-id", seat_id, NULL);
-
-        store_display (factory, num, display);
-
-        if (! gdm_display_manage (display)) {
-                display = NULL;
-                goto out;
-        }
+        display = create_display (factory, seat_id, GDM_TYPE_TRANSIENT_DISPLAY);
 
         if (! gdm_display_get_id (display, id, NULL)) {
                 display = NULL;
@@ -247,9 +234,6 @@ gdm_local_display_factory_create_transie
 
         ret = TRUE;
  out:
-        /* ref either held by store or not at all */
-        g_object_unref (display);
-
         return ret;
 }
 
@@ -302,14 +286,26 @@ gdm_local_display_factory_create_product
 }
 
 static void
+switch_to_login_session (GdmLocalDisplayFactory *factory)
+{
+        const char *seat_id;
+
+        /* FIXME: look for existing login session before starting a new one */
+        seat_id = get_seat_of_transient_display (factory);
+        create_display (factory, seat_id, GDM_TYPE_TRANSIENT_DISPLAY);
+}
+
+static void
 on_display_status_changed (GdmDisplay             *display,
                            GParamSpec             *arg1,
                            GdmLocalDisplayFactory *factory)
 {
         int              status;
+        gboolean         switch_on_finish;
         GdmDisplayStore *store;
         int              num;
         char            *seat_id = NULL;
+        GType            type;
 
         num = -1;
         gdm_display_get_x11_display_number (display, &num, NULL);
@@ -320,6 +316,8 @@ on_display_status_changed (GdmDisplay
         g_object_get (display, "seat-id", &seat_id, NULL);
 
         status = gdm_display_get_status (display);
+        switch_on_finish = gdm_display_get_switch_on_finish (display);
+        type = G_OBJECT_TYPE (display);
 
         g_debug ("GdmLocalDisplayFactory: display status changed: %d", status);
         switch (status) {
@@ -330,7 +328,12 @@ on_display_status_changed (GdmDisplay
                 gdm_display_store_remove (store, display);
                 /* reset num failures */
                 factory->priv->num_failures = 0;
-                create_display (factory, seat_id, GDM_TYPE_STATIC_DISPLAY);
+
+                if (switch_on_finish) {
+                	switch_to_login_session (factory);
+                 } else if (type == GDM_TYPE_STATIC_DISPLAY) {
+                 	create_display (factory, seat_id, type);
+                 }
                 break;
         case GDM_DISPLAY_FAILED:
                 /* leave the display number in factory->priv->displays
@@ -343,7 +346,7 @@ on_display_status_changed (GdmDisplay
                         /* FIXME: should monitor hardware changes to
                            try again when seats change */
                 } else {
-                        create_display (factory, seat_id, GDM_TYPE_STATIC_DISPLAY);
+                        create_display (factory, seat_id, type);
                 }
                 break;
         case GDM_DISPLAY_UNMANAGED:
@@ -400,6 +403,8 @@ create_display (GdmLocalDisplayFactory *
 
 	if (type == GDM_TYPE_STATIC_DISPLAY) {
 		display = gdm_static_display_new (num);
+	} else if (type == GDM_TYPE_TRANSIENT_DISPLAY) {
+		display = gdm_transient_display_new (num);
 	} else {
 		g_assert_not_reached ();
 	}
