Original patch: b21df58001691866b54ed4e0bf6d3d12ca6b4fa9
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 18 May 2011 01:49:22 -0400
Subject: [PATCH] daemon: parameterize create_display

There's some logic in create_display and friends,
that would be good to reuse for transient displays.

This commit adds a type argument to create_display
to say what kind of display to create.

Right now it only supports the one type it's always
supported, but that will change in a follow up commit.

https://bugzilla.gnome.org/show_bug.cgi?id=618047

Updated for changes in gdm 3.2.

Index: gdm-3.4.1/daemon/gdm-local-display-factory.c
===================================================================
--- gdm-3.4.1.orig/daemon/gdm-local-display-factory.c	2012-06-09 17:01:30.000000000 +0200
+++ gdm-3.4.1/daemon/gdm-local-display-factory.c	2012-06-09 17:17:04.007788210 +0200
@@ -73,7 +73,8 @@ static void     gdm_local_display_factor
 static void     gdm_local_display_factory_finalize      (GObject                     *object);
 
 static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory,
-                                                         const char                  *seat_id);
+                                                         const char                  *seat_id,
+                                                         GType                        type);
 
 static gpointer local_display_factory_object = NULL;
 
@@ -301,9 +302,9 @@ gdm_local_display_factory_create_product
 }
 
 static void
-on_static_display_status_changed (GdmDisplay             *display,
-                                  GParamSpec             *arg1,
-                                  GdmLocalDisplayFactory *factory)
+on_display_status_changed (GdmDisplay             *display,
+                           GParamSpec             *arg1,
+                           GdmLocalDisplayFactory *factory)
 {
         int              status;
         GdmDisplayStore *store;
@@ -320,7 +321,7 @@ on_static_display_status_changed (GdmDis
 
         status = gdm_display_get_status (display);
 
-        g_debug ("GdmLocalDisplayFactory: static display status changed: %d", status);
+        g_debug ("GdmLocalDisplayFactory: display status changed: %d", status);
         switch (status) {
         case GDM_DISPLAY_FINISHED:
                 /* remove the display number from factory->priv->displays
@@ -329,7 +330,7 @@ on_static_display_status_changed (GdmDis
                 gdm_display_store_remove (store, display);
                 /* reset num failures */
                 factory->priv->num_failures = 0;
-                create_display (factory, seat_id);
+                create_display (factory, seat_id, GDM_TYPE_STATIC_DISPLAY);
                 break;
         case GDM_DISPLAY_FAILED:
                 /* leave the display number in factory->priv->displays
@@ -342,7 +343,7 @@ on_static_display_status_changed (GdmDis
                         /* FIXME: should monitor hardware changes to
                            try again when seats change */
                 } else {
-                        create_display (factory, seat_id);
+                        create_display (factory, seat_id, GDM_TYPE_STATIC_DISPLAY);
                 }
                 break;
         case GDM_DISPLAY_UNMANAGED:
@@ -379,7 +380,8 @@ lookup_by_seat_id (const char *id,
 
 static GdmDisplay *
 create_display (GdmLocalDisplayFactory *factory,
-                const char             *seat_id)
+                const char             *seat_id,
+                GType                   type)
 {
         GdmDisplayStore *store;
         GdmDisplay      *display;
@@ -396,17 +398,17 @@ create_display (GdmLocalDisplayFactory *
 
         num = take_next_display_number (factory);
 
-#if 0
-        display = gdm_static_factory_display_new (num);
-#else
-        display = gdm_static_display_new (num);
-#endif
+	if (type == GDM_TYPE_STATIC_DISPLAY) {
+		display = gdm_static_display_new (num);
+	} else {
+		g_assert_not_reached ();
+	}
 
         g_object_set (display, "seat-id", seat_id, NULL);
 
         g_signal_connect (display,
                           "notify::status",
-                          G_CALLBACK (on_static_display_status_changed),
+                          G_CALLBACK (on_display_status_changed),
                           factory);
 
         store_display (factory, num, display);
@@ -490,7 +492,7 @@ static gboolean gdm_local_display_factor
                 }
 
                 dbus_message_iter_get_basic (&sub2, &seat);
-                create_display (factory, seat);
+                create_display (factory, seat, GDM_TYPE_STATIC_DISPLAY);
 
                 dbus_message_iter_next (&sub);
         }
@@ -524,7 +526,7 @@ on_seat_signal (DBusConnection *connecti
                 } else {
 
                         if (strcmp (dbus_message_get_member (message), "SeatNew") == 0) {
-                                create_display (factory, seat);
+                                create_display (factory, seat, GDM_TYPE_STATIC_DISPLAY);
                         } else {
                                 delete_display (factory, seat);
                         }
@@ -594,7 +596,7 @@ gdm_local_display_factory_start (GdmDisp
 #endif
 
         /* On ConsoleKit just create Seat1, and that's it. */
-        display = create_display (factory, CK_SEAT1_PATH);
+        display = create_display (factory, CK_SEAT1_PATH, GDM_TYPE_STATIC_DISPLAY);
 
         return display != NULL;
 }
