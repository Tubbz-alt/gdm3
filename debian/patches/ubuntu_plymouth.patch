Description: Saves the root window background so that other things like gnome-settings-daemon can access it.  Taken from the plymouth-integration branch of Upstream GIT.
From 9768d9e2783de7e836421d9645070bb1917800dd Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Fri, 27 Nov 2009 23:27:53 +0000
Subject: Save root window to pixmap at _XROOTPMAP_ID

This combined with starting the X server with -background none
will give us a nice fade transition when g-s-d starts
---
--- a/daemon/gdm-simple-slave.c
+++ b/daemon/gdm-simple-slave.c
@@ -91,6 +91,7 @@
 #ifdef  HAVE_LOGINDEVPERM
         gboolean           use_logindevperm;
 #endif
+        guint              plymouth_is_running : 1;
 };
 
 enum {
@@ -1098,6 +1099,91 @@
         slave->priv->start_session_when_ready = FALSE;
 }
 
+static gboolean
+plymouth_is_running (void)
+{
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        error = NULL;
+        res = g_spawn_command_line_sync ("/bin/plymouth --ping",
+                                         NULL, NULL, &status, &error);
+        if (! res) {
+                g_debug ("Could not ping plymouth: %s", error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        return WIFEXITED (status) && WEXITSTATUS (status) == 0;
+}
+
+static gboolean
+plymouth_has_active_vt (void)
+{
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        error = NULL;
+        res = g_spawn_command_line_sync ("/bin/plymouth --has-active-vt",
+                                         NULL, NULL, &status, &error);
+        if (! res) {
+                g_debug ("Could not ask plymouth: %s", error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        return WIFEXITED (status) && WEXITSTATUS (status) == 0;
+}
+
+static void
+plymouth_prepare_for_transition (GdmSimpleSlave *slave)
+{
+        gboolean res;
+        GError  *error;
+
+        error = NULL;
+        res = g_spawn_command_line_sync ("/bin/plymouth deactivate",
+                                         NULL, NULL, NULL, &error);
+        if (! res) {
+                g_warning ("Could not deactivate plymouth: %s", error->message);
+                g_error_free (error);
+        }
+}
+
+static void
+plymouth_quit_with_transition (GdmSimpleSlave *slave)
+{
+        gboolean res;
+        GError  *error;
+
+        error = NULL;
+        res = g_spawn_command_line_sync ("/bin/plymouth quit --retain-splash",
+                                         NULL, NULL, NULL, &error);
+        if (! res) {
+                g_warning ("Could not quit plymouth: %s", error->message);
+                g_error_free (error);
+        }
+        slave->priv->plymouth_is_running = FALSE;
+}
+
+static void
+plymouth_quit_without_transition (GdmSimpleSlave *slave)
+{
+        gboolean res;
+        GError  *error;
+
+        error = NULL;
+        res = g_spawn_command_line_sync ("/bin/plymouth quit",
+                                         NULL, NULL, NULL, &error);
+        if (! res) {
+                g_warning ("Could not quit plymouth: %s", error->message);
+                g_error_free (error);
+        }
+        slave->priv->plymouth_is_running = FALSE;
+}
+
 static void
 setup_server (GdmSimpleSlave *slave)
 {
@@ -1106,6 +1192,19 @@
 
         /* Set the busy cursor */
         gdm_slave_set_busy_cursor (GDM_SLAVE (slave));
+
+        /* The root window has a background that may be useful
+         * to cross fade or transition from when setting the
+         * login screen background.  We read it here, and stuff
+         * it into the standard _XROOTPMAP_ID root window property,
+         * so gnome-settings-daemon can get at it.
+         */
+        gdm_slave_save_root_windows (GDM_SLAVE (slave));
+
+        /* Plymouth is waiting for the go-ahead to exit */
+        if (slave->priv->plymouth_is_running) {
+                plymouth_quit_with_transition (slave);
+        }
 }
 
 static void
@@ -1305,6 +1404,10 @@
         g_debug ("GdmSimpleSlave: server exited with code %d\n", exit_code);
 
         gdm_slave_stopped (GDM_SLAVE (slave));
+
+        if (slave->priv->plymouth_is_running) {
+                plymouth_quit_without_transition (slave);
+        }
 }
 
 static void
@@ -1317,6 +1420,10 @@
                  g_strsignal (signal_number));
 
         gdm_slave_stopped (GDM_SLAVE (slave));
+
+        if (slave->priv->plymouth_is_running) {
+                plymouth_quit_without_transition (slave);
+        }
 }
 
 static gboolean
@@ -1361,7 +1468,21 @@
                                   G_CALLBACK (on_server_ready),
                                   slave);
 
-                res = gdm_server_start (slave->priv->server);
+                slave->priv->plymouth_is_running = plymouth_is_running ();
+
+                if (slave->priv->plymouth_is_running) {
+                        plymouth_prepare_for_transition (slave);
+
+			if (plymouth_has_active_vt ()) {
+				res = gdm_server_start_on_active_vt (slave->priv->server);
+			} else {
+                                plymouth_quit_without_transition (slave);
+				slave->priv->plymouth_is_running = 0;
+				res = gdm_server_start (slave->priv->server);
+			}
+                } else {
+                        res = gdm_server_start (slave->priv->server);
+                }
                 if (! res) {
                         g_warning (_("Could not start the X "
                                      "server (your graphical environment) "
@@ -1371,6 +1492,9 @@
                                      "In the meantime this display will be "
                                      "disabled.  Please restart GDM when "
                                      "the problem is corrected."));
+                        if (slave->priv->plymouth_is_running) {
+                                plymouth_quit_without_transition (slave);
+                        }
                         exit (1);
                 }
 
--- a/daemon/gdm-slave.c
+++ b/daemon/gdm-slave.c
@@ -43,6 +43,7 @@
 #include <dbus/dbus-glib-lowlevel.h>
 
 #include <X11/Xlib.h> /* for Display */
+#include <X11/Xatom.h> /* for XA_PIXMAP */
 #include <X11/cursorfont.h> /* for watch cursor */
 #include <X11/extensions/Xrandr.h>
 #include <X11/Xatom.h>
@@ -434,6 +435,77 @@
         }
 }
 
+static void
+gdm_slave_save_root_window_of_screen (GdmSlave *slave,
+                                      Atom      id_atom,
+                                      int       screen_number)
+{
+        Window root_window;
+        GC gc;
+        XGCValues values;
+        Pixmap pixmap;
+        int width, height, depth;
+
+        root_window = RootWindow (slave->priv->server_display,
+                                  screen_number);
+
+        width = DisplayWidth (slave->priv->server_display, screen_number);
+        height = DisplayHeight (slave->priv->server_display, screen_number);
+        depth = DefaultDepth (slave->priv->server_display, screen_number);
+        pixmap = XCreatePixmap (slave->priv->server_display,
+                                root_window,
+                                width, height, depth);
+
+        values.function = GXcopy;
+        values.plane_mask = AllPlanes;
+        values.fill_style = FillSolid;
+        values.subwindow_mode = IncludeInferiors;
+
+        gc = XCreateGC (slave->priv->server_display,
+                        root_window,
+                        GCFunction | GCPlaneMask | GCFillStyle | GCSubwindowMode,
+                        &values);
+
+        if (XCopyArea (slave->priv->server_display,
+                       root_window, pixmap, gc, 0, 0,
+                       width, height, 0, 0)) {
+
+                long pixmap_as_long;
+
+                pixmap_as_long = (long) pixmap;
+
+                XChangeProperty (slave->priv->server_display,
+                                 root_window, id_atom, XA_PIXMAP,
+                                 32, PropModeReplace, (guchar *) &pixmap_as_long,
+                                 1);
+
+        }
+
+        XFreeGC (slave->priv->server_display, gc);
+}
+
+void
+gdm_slave_save_root_windows (GdmSlave *slave)
+{
+        int i, number_of_screens;
+        Atom atom;
+
+        number_of_screens = ScreenCount (slave->priv->server_display);
+
+        atom = XInternAtom (slave->priv->server_display,
+                            "_XROOTPMAP_ID", False);
+
+        if (atom == 0) {
+                return;
+        }
+
+        for (i = 0; i < number_of_screens; i++) {
+                gdm_slave_save_root_window_of_screen (slave, atom, i);
+        }
+
+        XSync (slave->priv->server_display, False);
+}
+
 void
 gdm_slave_set_busy_cursor (GdmSlave *slave)
 {
--- a/daemon/gdm-slave.h
+++ b/daemon/gdm-slave.h
@@ -77,6 +77,7 @@
 void                gdm_slave_set_initial_cursor_position (GdmSlave *slave);
 
 void                gdm_slave_set_busy_cursor        (GdmSlave   *slave);
+void                gdm_slave_save_root_windows      (GdmSlave   *slave);
 gboolean            gdm_slave_run_script             (GdmSlave   *slave,
                                                       const char *dir,
                                                       const char *username);
--- a/daemon/gdm-server.c
+++ b/daemon/gdm-server.c
@@ -34,6 +34,9 @@
 #include <signal.h>
 #include <sys/resource.h>
 
+#include <sys/ioctl.h>
+#include <linux/vt.h>
+
 #ifdef HAVE_SYS_PRCTL_H
 #include <sys/prctl.h>
 #endif
@@ -673,6 +676,44 @@
         return ret;
 }
 
+static int
+get_active_vt (void)
+{
+        int console_fd;
+        struct vt_stat console_state = { 0 };
+
+        console_fd = open ("/dev/tty0", O_RDONLY | O_NOCTTY);
+
+        if (console_fd < 0) {
+                goto out;
+        }
+
+        if (ioctl (console_fd, VT_GETSTATE, &console_state) < 0) {
+                goto out;
+        }
+
+out:
+        if (console_fd >= 0) {
+                close (console_fd);
+        }
+
+        return console_state.v_active;
+}
+
+static char *
+get_active_vt_as_string (void)
+{
+        int vt;
+
+        vt = get_active_vt ();
+
+        if (vt <= 0) {
+                return NULL;
+        }
+
+        return g_strdup_printf ("vt%d", vt);
+}
+
 /**
  * gdm_server_start:
  * @disp: Pointer to a GdmDisplay structure
@@ -690,6 +731,21 @@
 
         return res;
 }
+
+gboolean
+gdm_server_start_on_active_vt (GdmServer *server)
+{
+        gboolean res;
+        char *vt;
+
+        g_free (server->priv->command);
+        server->priv->command = g_strdup (X_SERVER " -background none -verbose");
+        vt = get_active_vt_as_string ();
+        res = gdm_server_spawn (server, vt);
+        g_free (vt);
+
+        return res;
+}
 
 static void
 server_died (GdmServer *server)
--- a/daemon/gdm-server.h
+++ b/daemon/gdm-server.h
@@ -56,6 +56,7 @@
 GdmServer *         gdm_server_new       (const char *display_id,
                                           const char *auth_file);
 gboolean            gdm_server_start     (GdmServer   *server);
+gboolean            gdm_server_start_on_active_vt (GdmServer   *server);
 gboolean            gdm_server_stop      (GdmServer   *server);
 char *              gdm_server_get_display_device (GdmServer *server);
 
